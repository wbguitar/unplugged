// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.UnpVisualFxBase = (function() {
    function UnpVisualFxBase(targetCanvas, effectName) {
      this.targetCanvas = targetCanvas;
      this.effectName = effectName;
      this.configObject = {};
      this._cContext = this.targetCanvas.getContext('2d');
    }

    UnpVisualFxBase.prototype.Config = function(cfgObj) {
      var _ckey, _results;
      console.log;
      _results = [];
      for (_ckey in cfgObj) {
        _results.push(this.configObject[_ckey] = cfgObj[_ckey]);
      }
      return _results;
    };

    UnpVisualFxBase.prototype.Draw = function() {};

    return UnpVisualFxBase;

  })();

  window.UnpVisualFx = {};

  UnpVisualFx.StripeArray = (function(_super) {
    __extends(StripeArray, _super);

    function StripeArray(targetCanvas) {
      StripeArray.__super__.constructor.call(this, targetCanvas, 'StripeArray');
    }

    StripeArray.prototype._drawStripeCurve = function(_pointStart, _pointEnd, _bSpace) {
      var _diffAngle, _diffX, _diffY, _point1, _point2;
      _diffX = _pointEnd.x - _pointStart.x;
      _diffY = _pointEnd.y - _pointStart.y;
      _diffAngle = Math.atan2(_diffY, _diffX) + (Math.PI / 2);
      _point1 = {
        x: _pointStart.x + (_bSpace * Math.cos(_diffAngle)) + (_diffX / 4),
        y: _pointStart.y + (_bSpace * Math.sin(_diffAngle)) + (_diffY / 4)
      };
      _point2 = {
        x: _point1.x + (_diffX / 2),
        y: _point1.y + (_diffY / 2)
      };
      this._cContext.moveTo(_pointStart.x, _pointStart.y);
      return this._cContext.bezierCurveTo(_point1.x, _point1.y, _point2.x, _point2.y, _pointEnd.x, _pointEnd.y);
    };

    StripeArray.prototype._drawStripe = function(startX, startY, endX, endY, fillColor, minSpace, maxSpace) {
      var _pointEnd, _pointStart;
      this._cContext.beginPath();
      this._cContext.strokeStyle = fillColor;
      this._cContext.fillStyle = fillColor;
      this._cContext.lineWidth = 1;
      _pointStart = {
        x: startX,
        y: startY
      };
      _pointEnd = {
        x: endX,
        y: endY
      };
      this._drawStripeCurve(_pointStart, _pointEnd, minSpace);
      this._drawStripeCurve(_pointEnd, _pointStart, -maxSpace);
      this._cContext.fill();
      return this._cContext.closePath();
    };

    StripeArray.prototype._drawStripeArray = function(startX, startY, endX, endY, color1, color2, aWidth, stripeNum) {
      var i, _cColor, _cWidthEnd, _cWidthStart, _i, _sliceOffset, _startOffset;
      _startOffset = -(aWidth / 2);
      _sliceOffset = aWidth / stripeNum;
      if (color1 === null) {
        _cColor = color1;
      }
      this._drawStripe(startX, startY, endX, endY, _cColor, _startOffset, _startOffset + aWidth);
      for (i = _i = 0; 0 <= stripeNum ? _i <= stripeNum : _i >= stripeNum; i = 0 <= stripeNum ? ++_i : --_i) {
        if (i % 2 === 0) {
          continue;
        } else {
          _cColor = color2;
        }
      }
      _cWidthStart = _startOffset + (_sliceOffset * i);
      _cWidthEnd = _cWidthStart + _sliceOffset;
      return this._drawStripe(startX, startY, endX, endY, _cColor, _cWidthStart, _cWidthEnd);
    };

    StripeArray.prototype.Draw = function() {
      return this._drawStripeArray(this.configObject.startX, this.configObject.startY, this.configObject.endX, this.configObject.endY, this.configObject.color1, this.configObject.color2, this.configObject.stripeWidth, this.configObject.stripeNum);
    };

    return StripeArray;

  })(UnpVisualFxBase);

  UnpVisualFx.BezierArray = (function(_super) {
    __extends(BezierArray, _super);

    function BezierArray(targetCanvas) {
      BezierArray.__super__.constructor.call(this, targetCanvas, 'BezierArray');
    }

    BezierArray.prototype._drawBezierArray = function(startX, startY, endX, endY, colorFrom, colorTo, lineWidth, lineNum) {
      var i, _cLineColor, _diffX, _diffY, _distVal, _i, _point1X, _point1Y, _point2X, _point2Y, _results;
      _results = [];
      for (i = _i = 0; 0 <= lineNum ? _i <= lineNum : _i >= lineNum; i = 0 <= lineNum ? ++_i : --_i) {
        this._cContext.beginPath();
        _cLineColor = UnpUtils.randomColor(colorFrom, colorTo);
        this._cContext.strokeStyle = _cLineColor.getValue();
        this._cContext.lineWidth = Math.max(1, lineWidth * (0.5 + Math.random()));
        _distVal = 25;
        _diffX = endX - startX;
        _diffY = endY - startY;
        _point1X = startX + (0.333 * _diffX);
        _point1Y = startY + (0.333 * _diffY);
        _point2X = startX + (0.667 * _diffX);
        _point2Y = startY + (0.667 * _diffY);
        _point1X += (Math.random() - 0.5) * _distVal;
        _point1Y += (Math.random() - 0.5) * _distVal;
        _point2X += (Math.random() - 0.5) * _distVal;
        _point2Y += (Math.random() - 0.5) * _distVal;
        this._cContext.moveTo(startX, startY);
        this._cContext.bezierCurveTo(_point1X, _point1Y, _point2X, _point2Y, endX, endY);
        this._cContext.stroke();
        _results.push(this._cContext.closePath());
      }
      return _results;
    };

    BezierArray.prototype.Draw = function() {
      return this._drawBezierArray(this.configObject.startX, this.configObject.startY, this.configObject.endX, this.configObject.endY, this.configObject.colorFrom, this.configObject.colorTo, this.configObject.lineWidth, this.configObject.lineNum);
    };

    return BezierArray;

  })(UnpVisualFxBase);

  UnpVisualFx.LineArray = (function(_super) {
    __extends(LineArray, _super);

    function LineArray(targetCanvas) {
      LineArray.__super__.constructor.call(this, targetCanvas, 'LineArray');
    }

    LineArray.prototype._drawLineArray = function(startX, startY, endX, endY, colorFrom, colorTo, lineWidth, lineNum) {
      var i, j, _breakNum, _breakVal, _cLineColor, _cPointX, _cPointY, _diffX, _diffY, _distVal, _i, _j, _results;
      _results = [];
      for (i = _i = 0; 0 <= lineNum ? _i <= lineNum : _i >= lineNum; i = 0 <= lineNum ? ++_i : --_i) {
        this._cContext.beginPath();
        _cLineColor = UnpUtils.randomColor(colorFrom, colorTo);
        this._cContext.strokeStyle = _cLineColor.getValue();
        this._cContext.lineWidth = Math.max(1, lineWidth * (0.5 + Math.random()));
        _distVal = 20;
        _breakVal = 25;
        _diffX = endX - startX;
        _diffY = endY - startY;
        _breakNum = Math.ceil(Math.sqrt(Math.pow(_diffX, 2) + Math.pow(_diffY, 2)) / _breakVal);
        this._cContext.moveTo(startX, startY);
        for (j = _j = 0; 0 <= _breakNum ? _j <= _breakNum : _j >= _breakNum; j = 0 <= _breakNum ? ++_j : --_j) {
          _cPointX = startX + ((j / _breakNum) * _diffX);
          _cPointY = startY + ((j / _breakNum) * _diffY);
          _cPointX += (Math.random() - 0.5) * _distVal;
          _cPointY += (Math.random() - 0.5) * _distVal;
          this._cContext.lineTo(_cPointX, _cPointY);
        }
        this._cContext.lineTo(endX, endY);
        this._cContext.stroke();
        _results.push(this._cContext.closePath());
      }
      return _results;
    };

    LineArray.prototype.Draw = function() {
      console.log('' + this.configObject.startX + ' ', this.configObject.startY + ' ', this.configObject.endX + ' ', this.configObject.endY + ' ', this.configObject.colorFrom + ' ', this.configObject.colorTo + ' ', this.configObject.lineWidth + ' ', this.configObject.lineNum);
      return this._drawLineArray(this.configObject.startX, this.configObject.startY, this.configObject.endX, this.configObject.endY, this.configObject.colorFrom, this.configObject.colorTo, this.configObject.lineWidth, this.configObject.lineNum);
    };

    return LineArray;

  })(UnpVisualFxBase);

  UnpVisualFx.TimedBezier = (function(_super) {
    __extends(TimedBezier, _super);

    function TimedBezier(targetCanvas) {
      TimedBezier.__super__.constructor.call(this, targetCanvas, 'TimedBezier');
      this._pointArray = [];
      this.baseConfig = this.Config;
    }

    TimedBezier.prototype.Config = function(configObj) {
      var _maxDist, _pos1Angle, _pos2Angle;
      TimedBezier.__super__.Config.call(this, configObj);
      _maxDist = configObj.maxDist;
      if (_maxDist !== null) {
        _pos1Angle = Math.random() * Math.PI * 2;
        _pos2Angle = Math.random() * Math.PI * 2;
        this._pointArray[0] = {
          posX: Math.cos(_pos1Angle) * _maxDist * (0.5 + Math.random()),
          posY: Math.sin(_pos1Angle) * _maxDist * (0.5 + Math.random()),
          speedX: 0,
          speedY: 0,
          accX: 0,
          accY: 0
        };
        return this._pointArray[1] = {
          posX: Math.cos(_pos2Angle) * _maxDist * (0.5 + Math.random()),
          posY: Math.sin(_pos2Angle) * _maxDist * (0.5 + Math.random()),
          speedX: 0,
          speedY: 0,
          accX: 0,
          accY: 0
        };
      }
    };

    TimedBezier.prototype._drawTimedBezier = function(startX, startY, endX, endY, lineColor, lineWidth) {
      var _diffX, _diffY, _point1X, _point1Y, _point2X, _point2Y;
      console.log;
      this._cContext.beginPath();
      this._cContext.lineWidth = lineWidth;
      this._cContext.strokeStyle = lineColor.getValue();
      _diffX = endX - startX;
      _diffY = endY - startY;
      _point1X = startX + (_diffX * 0.333);
      _point1Y = startY + (_diffY * 0.333);
      _point2X = endX - (_diffX * 0.333);
      _point2Y = endY - (_diffY * 0.333);
      this._cContext.moveTo(startX, startY);
      this._cContext.bezierCurveTo(_point1X + this._pointArray[0].posX, _point1Y + this._pointArray[0].posY, _point2X + this._pointArray[1].posX, _point2Y + this._pointArray[1].posY, endX, endY);
      this._cContext.stroke();
      return this._cContext.closePath();
    };

    TimedBezier.prototype.Draw = function() {
      var point, _accAngle, _baseAcc, _i, _lastUpdate, _len, _nowTime, _ref, _timeDiff;
      _nowTime = new Date().getTime();
      _timeDiff = UnpUtils.getRefreshRate();
      _baseAcc = 200;
      _ref = this._pointArray;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        _accAngle = Math.atan2(-point.posY, -point.posX);
        point.accX = Math.cos(_accAngle) * _baseAcc;
        point.accY = Math.sin(_accAngle) * _baseAcc;
        point.speedX += point.accX * _timeDiff / 1000;
        point.speedY += point.accY * _timeDiff / 1000;
        point.posX += point.speedX * _timeDiff / 1000;
        point.posY += point.speedY * _timeDiff / 1000;
      }
      _lastUpdate = _nowTime;
      return this._drawTimedBezier(this.configObject.startX, this.configObject.startY, this.configObject.endX, this.configObject.endY, this.configObject.lineColor, this.configObject.lineWidth);
    };

    return TimedBezier;

  })(UnpVisualFxBase);

  UnpVisualFx.ParticleElement = (function() {
    function ParticleElement(particleEffect) {
      this.particleEffect = particleEffect;
      this.posX = 0;
      this.posY = 0;
      this.speedX = 0;
      this.speedY = 0;
      this.accelX = 0;
      this.accelY = 0;
      this.color = new UnpColor(255, 255, 255);
      this.width = 4;
      this.height = 4;
      this.creationTime = new Date().getTime();
      this.texture = null;
    }

    return ParticleElement;

  })();

  UnpVisualFx.ParticleEffect = (function(_super) {
    __extends(ParticleEffect, _super);

    function ParticleEffect(targetCanvas, effectName) {
      ParticleEffect.__super__.constructor.call(this, targetCanvas, effectName);
      this._particleArray = [];
      this._lastAddDiff = 0;
      this._firstUpdateTime = null;
      this._totalAddedParticles = 0;
    }

    ParticleEffect.prototype._UpdateParticles = function() {
      var i, j, _cParticle, _cycleTime, _doRegularUpdate, _heightDiff, _i, _j, _k, _l, _len, _len1, _lifePoint, _m, _particleNum, _particlesToAdd, _particlesToRemove, _ref, _ref1, _ref2, _ref3, _results, _timeDiff, _timeNow, _widthDiff;
      console.log;
      _timeNow = new Date().getTime();
      _timeDiff = UnpUtils.getRefreshRate();
      this._lastAddDiff += _timeDiff;
      if (this._firstUpdateTime === null) {
        this._firstUpdateTime = _timeNow;
      }
      _particleNum = this.configObject.particleNum;
      _particlesToRemove = [];
      _ref = this._particleArray;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _cParticle = _ref[_i];
        if ((_timeNow - _cParticle.creationTime) > this.configObject.lifeSpan) {
          _particlesToRemove.push(_cParticle);
        }
      }
      for (i = _j = 0, _ref1 = _particlesToRemove.length; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        for (j = _k = 0, _ref2 = this._particleArray.length; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
          if (this._particleArray[j] === _particlesToRemove[i]) {
            this._particleArray.splice(j, 1);
          }
        }
      }
      if (this._particleArray.length < _particleNum) {
        _cycleTime = this.configObject.lifeSpan;
        if (this.configObject.totalTime !== void 0) {
          _cycleTime = this.configObject.totalTime;
        }
        _particlesToAdd = Math.min(_particleNum - this._particleArray.length, _particleNum * (this._lastAddDiff / _cycleTime));
        _particlesToAdd = Math.floor(_particlesToAdd);
        if (this.configObject.totalTime !== void 0) {
          if (this._totalAddedParticles > _particleNum) {
            _particlesToAdd = 0;
          } else {
            _particlesToAdd = Math.min(_particlesToAdd, _particleNum - this._totalAddedParticles);
          }
          this._totalAddedParticles += _particlesToAdd;
        }
        for (i = _l = 0; 0 <= _particlesToAdd ? _l <= _particlesToAdd : _l >= _particlesToAdd; i = 0 <= _particlesToAdd ? ++_l : --_l) {
          console.log;
          _cParticle = new UnpVisualFx.ParticleElement(this);
          _cParticle.posX = this.configObject.posX;
          _cParticle.posY = this.configObject.posY;
          _cParticle.texture = this.configObject.texture;
          this._particleArray.push(_cParticle);
          this._lastAddDiff = 0;
          this.initializeParticle(_cParticle);
        }
      }
      _ref3 = this._particleArray;
      _results = [];
      for (_m = 0, _len1 = _ref3.length; _m < _len1; _m++) {
        _cParticle = _ref3[_m];
        _doRegularUpdate = this.updateParticle(_cParticle);
        if (_doRegularUpdate !== false) {
          _lifePoint = (_timeNow - _cParticle.creationTime) / this.configObject.lifeSpan;
          _widthDiff = this.configObject.endWidth - this.configObject.startWidth;
          _heightDiff = this.configObject.endHeight - this.configObject.startHeight;
          _cParticle.color = UnpUtils.colorBetween(this.configObject.startColor, this.configObject.endColor, _lifePoint);
          _cParticle.width = this.configObject.startWidth + (_widthDiff * _lifePoint);
          _cParticle.height = this.configObject.startHeight + (_heightDiff * _lifePoint);
          _cParticle.speedX += _timeDiff * _cParticle.accelX / 1000;
          _cParticle.speedY += _timeDiff * _cParticle.accelY / 1000;
          _cParticle.posX += _timeDiff * _cParticle.speedX / 1000;
          _results.push(_cParticle.posY += _timeDiff * _cParticle.speedY / 1000);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ParticleEffect.prototype.initializeParticle = function(cParticle) {};

    ParticleEffect.prototype.updateParticle = function(cParticle) {};

    ParticleEffect.prototype.Draw = function() {
      var _cColorEnd, _cColorStart, _cGradient, _cParticle, _finalX, _finalY, _i, _len, _ref, _results;
      this._UpdateParticles();
      console.log;
      _ref = this._particleArray;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _cParticle = _ref[_i];
        _finalX = _cParticle.posX;
        _finalY = _cParticle.posY;
        this._cContext.beginPath();
        if (_cParticle.texture === void 0) {
          console.log;
          this._cContext.fillStyle = _cParticle.color.getValue();
          this._cContext.arc(_finalX, _finalY, _cParticle.width, 0, Math.PI * 2, true);
          this._cContext.fill();
        } else if (typeof _cParticle.texture === 'string') {
          switch (_cParticle.texture) {
            case 'RadialFade':
              _cGradient = this._cContext.createRadialGradient(_finalX, _finalY, 0, _finalX, _finalY, _cParticle.width);
              _cColorStart = _cParticle.color;
              _cColorEnd = new UnpColor(_cParticle.color.Red, _cParticle.color.Green, _cParticle.color.Blue, 0);
              _cGradient.addColorStop(0, _cColorStart.getValue());
              _cGradient.addColorStop(1, _cColorEnd.getValue());
              this._cContext.fillStyle = _cGradient;
              this._cContext.arc(_finalX, _finalY, _cParticle.width, 0, Math.PI * 2, true);
              this._cContext.fill();
          }
        }
        _results.push(this._cContext.closePath());
      }
      return _results;
    };

    return ParticleEffect;

  })(UnpVisualFxBase);

  UnpVisualFx.Explosion = (function(_super) {
    __extends(Explosion, _super);

    function Explosion(targetCanvas) {
      Explosion.__super__.constructor.call(this, targetCanvas, 'Explosion');
      this.Config({
        particleNum: 50,
        lifeSpan: 1000,
        startWidth: 4,
        startHeight: 4,
        endWidth: 1,
        endHeight: 1,
        startColor: new UnpColor(225, 225, 50, 0.8),
        endColor: new UnpColor(115, 0, 0, 0.5),
        totalTime: 200
      });
    }

    Explosion.prototype.initializeParticle = function(currParticle) {
      var _explosionSpeed, _randomAngle;
      _randomAngle = Math.PI * 2 * Math.random();
      _explosionSpeed = 50 * (0.5 + Math.random());
      currParticle.speedX = Math.cos(_randomAngle) * _explosionSpeed;
      return currParticle.speedY = Math.sin(_randomAngle) * _explosionSpeed;
    };

    Explosion.prototype.updateParticle = function(currParticle) {};

    return Explosion;

  })(UnpVisualFx.ParticleEffect);

  UnpVisualFx.Flame = (function(_super) {
    __extends(Flame, _super);

    function Flame(targetCanvas) {
      Flame.__super__.constructor.call(this, targetCanvas, 'Flame');
      this.Config({
        particleNum: 25,
        lifeSpan: 1000,
        startWidth: 12,
        startHeight: 12,
        endWidth: 8,
        endHeight: 8,
        startColor: new UnpColor(250, 225, 50, 0.8),
        endColor: new UnpColor(115, 0, 0, 0.5),
        texture: 'RadialFade'
      });
    }

    Flame.prototype.initializeParticle = function(currParticle) {
      var _explosionSpeed, _flameAccelY, _randomAngle, _randomSpeed;
      console.log;
      _explosionSpeed = 40;
      _flameAccelY = -120;
      _randomAngle = Math.PI * 2 * Math.random();
      _randomSpeed = _explosionSpeed * Math.random();
      currParticle.speedX = Math.cos(_randomAngle) * _randomSpeed;
      currParticle.speedY = Math.sin(_randomAngle) * _randomSpeed;
      currParticle.accelY = _flameAccelY;
      return currParticle.accelX = -(currParticle.speedX * 2);
    };

    Flame.prototype.updateParticle = function(currParticle) {};

    return Flame;

  })(UnpVisualFx.ParticleEffect);

  UnpVisualFx.Swirl = (function(_super) {
    __extends(Swirl, _super);

    function Swirl(targetCanvas) {
      Swirl.__super__.constructor.call(this, targetCanvas, 'Swirl');
      this.Config({
        particleNum: 30,
        lifeSpan: 1000,
        startWidth: 4,
        startHeight: 4,
        endWidth: 1,
        endHeight: 1,
        startColor: new UnpColor(0, 225, 0, 0.8),
        endColor: new UnpColor(0, 0, 0, 0.5)
      });
    }

    Swirl.prototype.initializeParticle = function(currParticle) {
      var _particleSpeed, _timedAngle;
      console.log;
      _timedAngle = ((new Date().getTime() % 1000) / 1000) * Math.PI * 2;
      _particleSpeed = 30;
      currParticle.speedX = Math.cos(_timedAngle) * _particleSpeed;
      return currParticle.speedY = Math.sin(_timedAngle) * _particleSpeed;
    };

    Swirl.prototype.updateParticle = function(currParticle) {};

    return Swirl;

  })(UnpVisualFx.ParticleEffect);

  UnpVisualFx.Spiral = (function(_super) {
    __extends(Spiral, _super);

    function Spiral(targetCanvas) {
      Spiral.__super__.constructor.call(this, targetCanvas, 'Spiral');
      this.Config({
        particleNum: 50,
        lifeSpan: 1000,
        startWidth: 2,
        startHeight: 2,
        endWidth: 1,
        endHeight: 1,
        startColor: new UnpColor(150, 0, 225, 0.8),
        endColor: new UnpColor(255, 255, 255, 0)
      });
      this._nextArm = 0;
      this._armNum = 3;
    }

    Spiral.prototype.initializeParticle = function(currParticle) {
      var _armAngle, _particleSpeed, _timedAngle;
      console.log;
      _timedAngle = ((new Date().getTime() % 1000) / 1000) * Math.PI * 2;
      _particleSpeed = 30;
      _armAngle = ((Math.PI * 2) / this._armNum) * this._nextArm;
      currParticle.speedX = Math.cos(_timedAngle + _armAngle) * _particleSpeed;
      currParticle.speedY = Math.sin(_timedAngle + _armAngle) * _particleSpeed;
      this._nextArm++;
      return this._nextArm = this._nextArm % this._armNum;
    };

    Spiral.prototype.updateParticle = function(currParticle) {};

    return Spiral;

  })(UnpVisualFx.ParticleEffect);

}).call(this);

//# sourceMappingURL=unpvisualfx.map
