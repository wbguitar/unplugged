// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.UnpMoveIt = (function(_super) {
    __extends(UnpMoveIt, _super);

    function UnpMoveIt(htmlCont) {
      var loopCallback, self;
      UnpMoveIt.__super__.constructor.call(this, 'unpmoveit');
      this._isStarted = false;
      this._moveItData = {};
      this._fireData = [];
      this._boomData = [];
      this.moveDisplay = document.createElement('div');
      $(this.moveDisplay).addClass('unpmoveit-cont').html('<div class="unpmoveit-display"><canvas></canvas></div>');
      this._displayCanvas = $(this.moveDisplay).find('.unpmoveit-display canvas')[0];
      self = this;
      $(this.moveDisplay).find('.unpmoveit-display').bind('click', function(evtObj) {
        var _clickPosX, _clickPosY;
        _clickPosX = evtObj.clientX;
        _clickPosY = evtObj.clientY;
        return self.moveTo(_clickPosX - (this.offsetWidth / 2), _clickPosY - (this.offsetHeight / 2));
      });
      $(this.moveDisplay).find('.unpmoveit-display').bind('contextmenu', function(evtObj) {
        var _clickPosX, _clickPosY;
        evtObj.preventDefault();
        _clickPosX = evtObj.clientX;
        _clickPosY = evtObj.clientY;
        return self.fireTo(_clickPosX - (this.offsetWidth / 2), _clickPosY - (this.offsetHeight / 2));
      });
      $(htmlCont).append(this.moveDisplay);
      loopCallback = function() {
        var j, _HPBarWidth, _accelX, _accelY, _animateRadius, _animateRadiusFact, _animateRadiusMod, _animateRadiusTime, _bData, _baseAccel, _boomColor, _boomColorLight, _boomColorProg, _boomLifeSpan, _boomSize, _boomToRemove, _brakePower, _cContext, _cData, _cRemoveObject, _centerX, _centerY, _circleRadius, _ckey, _diffModule, _diffX, _diffXRatio, _diffY, _diffYRatio, _effectiveHPBarWidth, _fData, _finalX, _finalY, _finalgoToX, _finalgoToY, _fireLifeSpan, _fireRadius, _fireToRemove, _fontSize, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _maxSpeed, _n, _nowTime, _o, _p, _q, _randomAngle, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _speedModule, _updateTimeDiff;
        if (self._isStarted === true) {
          _cContext = self._displayCanvas.getContext("2d");
          _baseAccel = self._baseCostants.baseaccel;
          _maxSpeed = self._baseCostants.maxspeed;
          _brakePower = self._baseCostants.brakepower;
          _fireLifeSpan = self._baseCostants.firelifespan;
          _boomLifeSpan = self._baseCostants.boomlifespan;
          _nowTime = new Date().getTime();
          _fireToRemove = [];
          _ref = self._fireData;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _fData = _ref[_i];
            if (_nowTime - _fData.creationTime > _fireLifeSpan) {
              _fireToRemove.push(_fData);
            } else {
              _updateTimeDiff = (_nowTime - _fData.lastUpdate) / 1000;
              _fData.fireX += _fData.fireSpeedX * _updateTimeDiff;
              _fData.fireY += _fData.fireSpeedY * _updateTimeDiff;
              _fData.lastUpdate = _nowTime;
            }
          }
          for (_j = 0, _len1 = _fireToRemove.length; _j < _len1; _j++) {
            _cRemoveObject = _fireToRemove[_j];
            _bData = {};
            _bData.boomX = _cRemoveObject.fireX;
            _bData.boomY = _cRemoveObject.fireY;
            _bData.creationTime = _nowTime;
            self._boomData.push(_bData);
            for (j = _k = 0, _ref1 = self._fireData.length; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; j = 0 <= _ref1 ? ++_k : --_k) {
              if (self._fireData[j] === _cRemoveObject) {
                self._fireData[j] = null;
                self._fireData.splice(j, 1);
                break;
              }
            }
          }
          _boomToRemove = [];
          _ref2 = self._boomData;
          for (_l = 0, _len2 = _ref2.length; _l < _len2; _l++) {
            _bData = _ref2[_l];
            if (_nowTime - _bData.creationTime > _boomLifeSpan) {
              _boomToRemove.push(_bData);
            }
          }
          for (_m = 0, _len3 = _boomToRemove.length; _m < _len3; _m++) {
            _cRemoveObject = _boomToRemove[_m];
            for (j = _n = 0, _ref3 = self._boomData.length; 0 <= _ref3 ? _n <= _ref3 : _n >= _ref3; j = 0 <= _ref3 ? ++_n : --_n) {
              if (self._boomData[j] === _cRemoveObject) {
                self._boomData[j] = null;
                self._boomData.splice(j, 1);
                break;
              }
            }
          }
          console.log;
          for (_ckey in self._moveItData) {
            console.log;
            _cData = self._moveItData[_ckey];
            _updateTimeDiff = (_nowTime - _cData.lastUpdate) / 1000;
            _diffX = -(_cData.x - _cData.goToX);
            _diffY = -(_cData.y - _cData.goToY);
            if ((Math.abs(_diffX) < 0.5) && (Math.abs(_diffY) < 0.5)) {
              _diffY = 0;
              _cData.y = _cData.goToY;
              _cData.speedY = 0;
              _diffX = 0;
              _cData.x = _cData.goToX;
              _cData.speedX = 0;
              _cData.animationTime = null;
            }
            _diffModule = Math.sqrt(Math.pow(_diffX, 2) + Math.pow(_diffY, 2));
            if (_diffX !== 0) {
              _diffXRatio = _diffX / _diffModule;
              _accelX = _baseAccel * _diffXRatio;
              if (Math.abs(_cData.speedX) / _brakePower > Math.abs(_diffX)) {
                _accelX = -_cData.speedX * _brakePower;
              }
              _cData.speedX += _accelX * _updateTimeDiff;
            }
            if (_diffY !== 0) {
              _diffYRatio = _diffY / _diffModule;
              _accelY = _baseAccel * _diffYRatio;
              if (Math.abs(_cData.speedY) / _brakePower > Math.abs(_diffY)) {
                _accelY = -_cData.speedY * _brakePower;
              }
              _cData.speedY += _accelY * _updateTimeDiff;
            }
            _speedModule = Math.sqrt(Math.pow(_cData.speedX, 2) + Math.pow(_cData.speedY, 2));
            if (_speedModule > _maxSpeed) {
              _cData.speedX = _maxSpeed * _cData.speedX / _speedModule;
              _cData.speedY = _maxSpeed * _cData.speedY / _speedModule;
            }
            _cData.x += _cData.speedX * _updateTimeDiff;
            _cData.y += _cData.speedY * _updateTimeDiff;
            _cData.lastUpdate = _nowTime;
          }
          _circleRadius = self._baseCostants.circleradius;
          _fireRadius = self._baseCostants.fireradius;
          _boomSize = self._baseCostants.boomsize;
          _animateRadiusTime = 1000;
          _fontSize = 12;
          _HPBarWidth = 24;
          _centerX = self._displayCanvas.offsetWidth / 2;
          _centerY = self._displayCanvas.offsetHeight / 2;
          _cContext.clearRect(0, 0, self._displayCanvas.offsetWidth, self._displayCanvas.offsetHeight);
          _cContext.lineWidth = 1;
          _ref4 = self._boomData.length;
          for (_o = 0, _len4 = _ref4.length; _o < _len4; _o++) {
            _bData = _ref4[_o];
            _finalX = _centerX + parseInt(_bData.boomX, 10);
            _finalY = _centerY + parseInt(_bData.boomY, 10);
            _boomColorProg = (_boomLifeSpan - (_nowTime - _bData.creationTime)) / _boomLifeSpan;
            _boomColorLight = Math.round(255 * (1 - _boomColorProg));
            _boomColor = 'rgba(' + _boomColorLight + ',' + _boomColorLight + ',255,' + _boomColorProg + ')';
            _cContext.strokeStyle = _boomColor;
            _cContext.fillStyle = _boomColor;
            _cContext.beginPath();
            _cContext.moveTo(_finalX, _finalY);
            _randomAngle = Math.random() * Math.PI * 2;
            _cContext.moveTo(_finalX + Math.cos(_randomAngle - 0.5) * _boomSize, _finalY + Math.sin(_randomAngle - 0.5) * _boomSize);
            for (j = _p = 0; _p <= 3; j = ++_p) {
              _randomAngle = Math.random() * Math.PI * 2;
              _cContext.lineTo(_finalX + Math.cos(_randomAngle - 0.5) * _boomSize, _finalY + Math.sin(_randomAngle - 0.5) * _boomSize);
            }
            _cContext.stroke();
            _cContext.closePath();
          }
          _ref5 = self._fireData;
          for (_q = 0, _len5 = _ref5.length; _q < _len5; _q++) {
            _fData = _ref5[_q];
            _finalX = _centerX + parseInt(_fData.fireX, 10);
            _finalY = _centerY + parseInt(_fData.fireY, 10);
            _cContext.strokeStyle = '#ffffff';
            _cContext.fillStyle = '#ffffff';
            _cContext.beginPath();
            _cContext.arc(_finalX, _finalY, _fireRadius, 0, Math.PI * 2, true);
            _cContext.fill();
            _cContext.closePath();
          }
          for (_ckey in self._moveItData) {
            console.log;
            _cData = self._moveItData[_ckey];
            _finalX = _centerX + parseInt(_cData.x, 10);
            _finalY = _centerY + parseInt(_cData.y, 10);
            _finalgoToX = _centerX + parseInt(_cData.goToX, 10);
            _finalgoToY = _centerY + parseInt(_cData.goToY, 10);
            _cContext.strokeStyle = '#ffffff';
            _cContext.fillStyle = '#ffffff';
            _cContext.textAlign = 'center';
            _cContext.font = _fontSize + "px verdana";
            _cContext.fillText(_cData.name, _finalX, _finalY + _circleRadius + _fontSize);
            _effectiveHPBarWidth = _HPBarWidth * _cData.hp / 100;
            _cContext.fillRect(_finalX - _effectiveHPBarWidth / 2, _finalY - (_circleRadius + _fontSize), _effectiveHPBarWidth, _fontSize / 2);
            if (_cData.dead) {
              _cContext.strokeStyle = 'rgba(100, 100, 100, 0.5)';
              _cContext.fillStyle = 'rgba(100, 100, 100, 0.5)';
            } else {
              _cContext.strokeStyle = _cData.color;
              _cContext.fillStyle = _cData.color;
            }
            _cContext.beginPath();
            _cContext.arc(_finalgoToX, _finalgoToY, _circleRadius / 5, 0, Math.PI * 2, true);
            _cContext.fill();
            _cContext.closePath();
            _animateRadius = 0;
            if (_cData.animationTime) {
              _animateRadiusMod = ((_nowTime - _cData.animationTime) % _animateRadiusTime) / _animateRadiusTime;
              _animateRadiusFact = 0;
              if (_animateRadiusMod < 0.25) {
                _animateRadiusFact = -_animateRadiusMod;
              } else if (_animateRadiusMod < 0.75) {
                _animateRadiusFact = -0.5 + _animateRadiusMod;
              } else {
                _animateRadiusFact = 1 - _animateRadiusMod;
              }
              _animateRadiusMod += 0.25;
              _animateRadius = _circleRadius * 0.8 * _animateRadiusFact;
            }
            _cContext.beginPath();
            _cContext.lineWidth = _circleRadius / 2;
            _cContext.arc(_finalX, _finalY, _circleRadius + _animateRadius, 0, Math.PI * 2, true);
            _cContext.stroke();
            _cContext.closePath();
          }
          if (window._testVisualFx) {
            return $(window._testVisualFx).each(function() {
              console.log('');
              switch (self.effectName) {
                case 'StripeArray':
                case 'BezierArray':
                case 'LineArray':
                case 'TimedBezier':
                  self.configObject.startX = self._displayCanvas.offsetWidth - _finalX;
                  self.configObject.startY = self._displayCanvas.offsetHeight - _finalY;
                  self.configObject.endX = _finalX;
                  self.configObject.endY = _finalY;
                  break;
                case 'Explosion':
                case 'Flame':
                case 'Swirl':
                case 'Spiral':
                  self.configObject.posX = self._displayCanvas.offsetWidth - _finalX;
                  self.configObject.posY = self._displayCanvas.offsetHeight - _finalY;
              }
              console.log('');
              return this.Draw();
            });
          }
        }
      };
      window.setInterval((function() {
        return self._loopCallback(self);
      }), UnpUtils.getRefreshRate());
    }

    UnpMoveIt.prototype._loopCallback = function(self) {
      var j, _HPBarWidth, _accelX, _accelY, _animateRadius, _animateRadiusFact, _animateRadiusMod, _animateRadiusTime, _bData, _baseAccel, _boomColor, _boomColorLight, _boomColorProg, _boomLifeSpan, _boomSize, _boomToRemove, _brakePower, _cContext, _cData, _cRemoveObject, _centerX, _centerY, _circleRadius, _ckey, _diffModule, _diffX, _diffXRatio, _diffY, _diffYRatio, _effectiveHPBarWidth, _fData, _finalX, _finalY, _finalgoToX, _finalgoToY, _fireLifeSpan, _fireRadius, _fireToRemove, _fontSize, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _maxSpeed, _n, _nowTime, _o, _p, _q, _randomAngle, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _speedModule, _updateTimeDiff;
      if (self._isStarted === true) {
        _cContext = self._displayCanvas.getContext("2d");
        _baseAccel = self._baseCostants.baseaccel;
        _maxSpeed = self._baseCostants.maxspeed;
        _brakePower = self._baseCostants.brakepower;
        _fireLifeSpan = self._baseCostants.firelifespan;
        _boomLifeSpan = self._baseCostants.boomlifespan;
        _nowTime = new Date().getTime();
        _fireToRemove = [];
        _ref = self._fireData;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _fData = _ref[_i];
          if (_nowTime - _fData.creationTime > _fireLifeSpan) {
            _fireToRemove.push(_fData);
          } else {
            _updateTimeDiff = (_nowTime - _fData.lastUpdate) / 1000;
            _fData.fireX += _fData.fireSpeedX * _updateTimeDiff;
            _fData.fireY += _fData.fireSpeedY * _updateTimeDiff;
            _fData.lastUpdate = _nowTime;
          }
        }
        for (_j = 0, _len1 = _fireToRemove.length; _j < _len1; _j++) {
          _cRemoveObject = _fireToRemove[_j];
          _bData = {};
          _bData.boomX = _cRemoveObject.fireX;
          _bData.boomY = _cRemoveObject.fireY;
          _bData.creationTime = _nowTime;
          self._boomData.push(_bData);
          for (j = _k = 0, _ref1 = self._fireData.length; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; j = 0 <= _ref1 ? ++_k : --_k) {
            if (self._fireData[j] === _cRemoveObject) {
              self._fireData[j] = null;
              self._fireData.splice(j, 1);
              break;
            }
          }
        }
        _boomToRemove = [];
        _ref2 = self._boomData;
        for (_l = 0, _len2 = _ref2.length; _l < _len2; _l++) {
          _bData = _ref2[_l];
          if (_nowTime - _bData.creationTime > _boomLifeSpan) {
            _boomToRemove.push(_bData);
          }
        }
        for (_m = 0, _len3 = _boomToRemove.length; _m < _len3; _m++) {
          _cRemoveObject = _boomToRemove[_m];
          for (j = _n = 0, _ref3 = self._boomData.length; 0 <= _ref3 ? _n <= _ref3 : _n >= _ref3; j = 0 <= _ref3 ? ++_n : --_n) {
            if (self._boomData[j] === _cRemoveObject) {
              self._boomData[j] = null;
              self._boomData.splice(j, 1);
              break;
            }
          }
        }
        console.log;
        for (_ckey in self._moveItData) {
          console.log;
          _cData = self._moveItData[_ckey];
          _updateTimeDiff = (_nowTime - _cData.lastUpdate) / 1000;
          _diffX = -(_cData.x - _cData.goToX);
          _diffY = -(_cData.y - _cData.goToY);
          if ((Math.abs(_diffX) < 0.5) && (Math.abs(_diffY) < 0.5)) {
            _diffY = 0;
            _cData.y = _cData.goToY;
            _cData.speedY = 0;
            _diffX = 0;
            _cData.x = _cData.goToX;
            _cData.speedX = 0;
            _cData.animationTime = null;
          }
          _diffModule = Math.sqrt(Math.pow(_diffX, 2) + Math.pow(_diffY, 2));
          if (_diffX !== 0) {
            _diffXRatio = _diffX / _diffModule;
            _accelX = _baseAccel * _diffXRatio;
            if (Math.abs(_cData.speedX) / _brakePower > Math.abs(_diffX)) {
              _accelX = -_cData.speedX * _brakePower;
            }
            _cData.speedX += _accelX * _updateTimeDiff;
          }
          if (_diffY !== 0) {
            _diffYRatio = _diffY / _diffModule;
            _accelY = _baseAccel * _diffYRatio;
            if (Math.abs(_cData.speedY) / _brakePower > Math.abs(_diffY)) {
              _accelY = -_cData.speedY * _brakePower;
            }
            _cData.speedY += _accelY * _updateTimeDiff;
          }
          _speedModule = Math.sqrt(Math.pow(_cData.speedX, 2) + Math.pow(_cData.speedY, 2));
          if (_speedModule > _maxSpeed) {
            _cData.speedX = _maxSpeed * _cData.speedX / _speedModule;
            _cData.speedY = _maxSpeed * _cData.speedY / _speedModule;
          }
          _cData.x += _cData.speedX * _updateTimeDiff;
          _cData.y += _cData.speedY * _updateTimeDiff;
          _cData.lastUpdate = _nowTime;
        }
        _circleRadius = self._baseCostants.circleradius;
        _fireRadius = self._baseCostants.fireradius;
        _boomSize = self._baseCostants.boomsize;
        _animateRadiusTime = 1000;
        _fontSize = 12;
        _HPBarWidth = 24;
        _centerX = self._displayCanvas.offsetWidth / 2;
        _centerY = self._displayCanvas.offsetHeight / 2;
        _cContext.clearRect(0, 0, self._displayCanvas.offsetWidth, self._displayCanvas.offsetHeight);
        _cContext.lineWidth = 1;
        _ref4 = self._boomData.length;
        for (_o = 0, _len4 = _ref4.length; _o < _len4; _o++) {
          _bData = _ref4[_o];
          _finalX = _centerX + parseInt(_bData.boomX, 10);
          _finalY = _centerY + parseInt(_bData.boomY, 10);
          _boomColorProg = (_boomLifeSpan - (_nowTime - _bData.creationTime)) / _boomLifeSpan;
          _boomColorLight = Math.round(255 * (1 - _boomColorProg));
          _boomColor = 'rgba(' + _boomColorLight + ',' + _boomColorLight + ',255,' + _boomColorProg + ')';
          _cContext.strokeStyle = _boomColor;
          _cContext.fillStyle = _boomColor;
          _cContext.beginPath();
          _cContext.moveTo(_finalX, _finalY);
          _randomAngle = Math.random() * Math.PI * 2;
          _cContext.moveTo(_finalX + Math.cos(_randomAngle - 0.5) * _boomSize, _finalY + Math.sin(_randomAngle - 0.5) * _boomSize);
          for (j = _p = 0; _p <= 3; j = ++_p) {
            _randomAngle = Math.random() * Math.PI * 2;
            _cContext.lineTo(_finalX + Math.cos(_randomAngle - 0.5) * _boomSize, _finalY + Math.sin(_randomAngle - 0.5) * _boomSize);
          }
          _cContext.stroke();
          _cContext.closePath();
        }
        _ref5 = self._fireData;
        for (_q = 0, _len5 = _ref5.length; _q < _len5; _q++) {
          _fData = _ref5[_q];
          _finalX = _centerX + parseInt(_fData.fireX, 10);
          _finalY = _centerY + parseInt(_fData.fireY, 10);
          _cContext.strokeStyle = '#ffffff';
          _cContext.fillStyle = '#ffffff';
          _cContext.beginPath();
          _cContext.arc(_finalX, _finalY, _fireRadius, 0, Math.PI * 2, true);
          _cContext.fill();
          _cContext.closePath();
        }
        for (_ckey in self._moveItData) {
          console.log;
          _cData = self._moveItData[_ckey];
          _finalX = _centerX + parseInt(_cData.x, 10);
          _finalY = _centerY + parseInt(_cData.y, 10);
          _finalgoToX = _centerX + parseInt(_cData.goToX, 10);
          _finalgoToY = _centerY + parseInt(_cData.goToY, 10);
          _cContext.strokeStyle = '#ffffff';
          _cContext.fillStyle = '#ffffff';
          _cContext.textAlign = 'center';
          _cContext.font = _fontSize + "px verdana";
          _cContext.fillText(_cData.name, _finalX, _finalY + _circleRadius + _fontSize);
          _effectiveHPBarWidth = _HPBarWidth * _cData.hp / 100;
          _cContext.fillRect(_finalX - _effectiveHPBarWidth / 2, _finalY - (_circleRadius + _fontSize), _effectiveHPBarWidth, _fontSize / 2);
          if (_cData.dead) {
            _cContext.strokeStyle = 'rgba(100, 100, 100, 0.5)';
            _cContext.fillStyle = 'rgba(100, 100, 100, 0.5)';
          } else {
            _cContext.strokeStyle = _cData.color;
            _cContext.fillStyle = _cData.color;
          }
          _cContext.beginPath();
          _cContext.arc(_finalgoToX, _finalgoToY, _circleRadius / 5, 0, Math.PI * 2, true);
          _cContext.fill();
          _cContext.closePath();
          _animateRadius = 0;
          if (_cData.animationTime) {
            _animateRadiusMod = ((_nowTime - _cData.animationTime) % _animateRadiusTime) / _animateRadiusTime;
            _animateRadiusFact = 0;
            if (_animateRadiusMod < 0.25) {
              _animateRadiusFact = -_animateRadiusMod;
            } else if (_animateRadiusMod < 0.75) {
              _animateRadiusFact = -0.5 + _animateRadiusMod;
            } else {
              _animateRadiusFact = 1 - _animateRadiusMod;
            }
            _animateRadiusMod += 0.25;
            _animateRadius = _circleRadius * 0.8 * _animateRadiusFact;
          }
          _cContext.beginPath();
          _cContext.lineWidth = _circleRadius / 2;
          _cContext.arc(_finalX, _finalY, _circleRadius + _animateRadius, 0, Math.PI * 2, true);
          _cContext.stroke();
          _cContext.closePath();
        }
        if (window._testVisualFx) {
          return $(window._testVisualFx).each(function() {
            console.log;
            switch (this.effectName) {
              case 'StripeArray':
              case 'BezierArray':
              case 'LineArray':
              case 'TimedBezier':
                this.configObject.startX = self._displayCanvas.offsetWidth - _finalX;
                this.configObject.startY = self._displayCanvas.offsetHeight - _finalY;
                this.configObject.endX = _finalX;
                this.configObject.endY = _finalY;
                break;
              case 'Explosion':
              case 'Flame':
              case 'Swirl':
              case 'Spiral':
                this.configObject.posX = self._displayCanvas.offsetWidth - _finalX;
                this.configObject.posY = self._displayCanvas.offsetHeight - _finalY;
            }
            console.log;
            return this.Draw();
          });
        }
      }
    };

    UnpMoveIt.prototype.handleAction = function(actionName, actionData) {
      var _cData, _diffModule, _diffX, _diffY, _fData, _fireSpeed, _fireStartDist;
      console.log;
      switch (actionName) {
        case 'init':
          $(this.moveDisplay).addClass('unpmoveit-started');
          this._isStarted = true;
          _UnpMoveToResize();
          return this._baseCostants = actionData;
        case 'add':
          _cData = {};
          _cData.color = actionData.color;
          _cData.name = actionData.name;
          _cData.x = parseInt(actionData.x, 10);
          _cData.y = parseInt(actionData.y, 10);
          _cData.goToX = parseInt(actionData.x, 10);
          _cData.goToY = parseInt(actionData.y, 10);
          _cData.speedX = 0;
          _cData.speedY = 0;
          _cData.hp = parseInt(actionData.hp, 10);
          _cData.dead = actionData.dead.toLowerCase() === 'true';
          _cData.lastUpdate = new Date().getTime();
          return this._moveItData[actionData['id']] = _cData;
        case 'move':
          _cData = this._moveItData[actionData['id']];
          _cData.goToX = parseInt(actionData['x'], 10);
          _cData.goToY = parseInt(actionData['y'], 10);
          if (_cData.animationTime) {
            return _cData.animationTime = new Date().getTime();
          }
          break;
        case 'sethp':
          _cData = this._moveItData[actionData['id']];
          _cData.hp = parseInt(actionData.hp, 10);
          return _cData.dead = actionData.dead.toLowerCase() === 'true';
        case 'fire':
          console.log;
          _cData = this._moveItData[actionData['id']];
          _fireSpeed = this._baseCostants.firespeed;
          _fireStartDist = this._baseCostants.firestartdist;
          _fData = {};
          _fData.fireX = parseInt(_cData.x, 10);
          _fData.fireY = parseInt(_cData.y, 10);
          _fData.fireToX = parseInt(actionData['x'], 10);
          _fData.fireToY = parseInt(actionData['y'], 10);
          _fData.creationTime = new Date().getTime();
          _fData.lastUpdate = _fData.creationTime;
          _diffX = -(_fData.fireX - _fData.fireToX);
          _diffY = -(_fData.fireY - _fData.fireToY);
          _diffModule = Math.sqrt(Math.pow(_diffX, 2) + Math.pow(_diffY, 2));
          _fData.fireSpeedX = _fireSpeed * _diffX / _diffModule;
          _fData.fireSpeedY = _fireSpeed * _diffY / _diffModule;
          _fData.fireX += _fireStartDist * _diffX / _diffModule;
          _fData.fireY += _fireStartDist * _diffY / _diffModule;
          return this._fireData.push(_fData);
        case 'del':
          this._moveItData[actionData['id']] = null;
          return delete this._moveItData[actionData['id']];
      }
    };

    UnpMoveIt.prototype.moveTo = function(xPos, yPos) {
      var _umpMsg;
      _umpMsg = new UnpMessage();
      _umpMsg.addAction(this.modName, 'move', {
        'x': Math.round(xPos),
        'y': Math.round(yPos)
      });
      return _umpMsg.send();
    };

    UnpMoveIt.prototype.fireTo = function(xPos, yPos) {
      var _umpMsg;
      _umpMsg = new UnpMessage();
      _umpMsg.addAction(this.modName, 'fire', {
        'x': Math.round(xPos),
        'y': Math.round(yPos)
      });
      return _umpMsg.send();
    };

    return UnpMoveIt;

  })(window.UnpModule);

  window._UnpMoveToResize = function() {
    return $('.unpmoveit-display canvas').each(function() {
      $(this).attr('width', this.parentElement.offsetWidth);
      $(this).attr('height', this.parentElement.offsetHeight);
      return this.getContext("2d").clearRect(0, 0, this.offsetWidth, this.offsetHeight);
    });
  };

  $(window).bind('resize', window._UnpMoveToResize);

}).call(this);

//# sourceMappingURL=moveit.map
